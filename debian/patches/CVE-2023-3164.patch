From 7ec6f53745ab6331382e59373ffd980b38a378f0 Mon Sep 17 00:00:00 2001
From: Lee Howard <faxguy@howardsilvan.com>
Date: Wed, 13 Mar 2024 10:06:21 -0700
Subject: [PATCH] fix tiffcrop issues #552, #550, and #542

---

Index: tiff-4.1.0+git191117/tools/tiffcrop.c
===================================================================
--- tiff-4.1.0+git191117.orig/tools/tiffcrop.c
+++ tiff-4.1.0+git191117/tools/tiffcrop.c
@@ -451,6 +451,7 @@ static uint16 defcompression = (uint16)
 static uint16 defpredictor = (uint16) -1;
 static int    pageNum = 0;
 static int    little_endian = 1;
+static tmsize_t check_buffsize = 0;
 
 /* Functions adapted from tiffcp with additions or significant modifications */
 static int  readContigStripsIntoBuffer   (TIFF*, uint8*);
@@ -2046,6 +2047,11 @@ void  process_command_opts (int argc, ch
 		  TIFFError ("Limit for subdivisions, ie rows x columns, exceeded", "%d", MAX_SECTIONS);
 		  exit (-1);
                   }
+                if ((page->cols * page->rows) < 1)
+                  {
+                  TIFFError("No subdivisions", "%d", (page->cols * page->rows));
+                  exit(EXIT_FAILURE);
+                  }
                 page->mode |= PAGE_MODE_ROWSCOLS;
 		break;
       case 'U':	/* units for measurements and offsets */
@@ -6257,6 +6263,7 @@ loadImage(TIFF* in, struct image_data *i
     TIFFError("loadImage", "Unable to allocate read buffer");
     return (-1);
     }
+  check_buffsize = buffsize + NUM_BUFF_OVERSIZE_BYTES;
 
   read_buff[buffsize] = 0;
   read_buff[buffsize+1] = 0;
@@ -6887,6 +6894,11 @@ extractImageSection(struct image_data *i
 #ifdef DEVELMODE
         TIFFError ("", "Src offset: %8d, Dst offset: %8d", src_offset, dst_offset); 
 #endif
+      if (src_offset + full_bytes >= check_buffsize)
+        {
+        printf("Bad input. Preventing reading outside of input buffer.\n");
+        return(-1);
+        }
       _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);
       dst_offset += full_bytes;
       }        
@@ -6921,6 +6933,11 @@ extractImageSection(struct image_data *i
       bytebuff1 = bytebuff2 = 0;
       if (shift1 == 0) /* the region is byte and sample aligned */
         {
+        if (offset1 + full_bytes >= check_buffsize)
+          {
+          printf("Bad input. Preventing reading outside of input buffer.\n");
+          return(-1);
+          }
 	_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);
 
 #ifdef DEVELMODE
@@ -6940,6 +6957,11 @@ extractImageSection(struct image_data *i
         if (trailing_bits != 0)
           {
       /* Only copy higher bits of samples and mask lower bits of not wanted column samples to zero */
+          if (offset1 + full_bytes >= check_buffsize)
+            {
+            printf("Bad input. Preventing reading outside of input buffer.\n");
+            return(-1);
+            }
 	  bytebuff2 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (8 - trailing_bits));
           sect_buff[dst_offset] = bytebuff2;
 #ifdef DEVELMODE
@@ -6965,6 +6987,11 @@ extractImageSection(struct image_data *i
           {
           /* Skip the first shift1 bits and shift the source up by shift1 bits before save to destination.*/
           /* Attention: src_buff size needs to be some bytes larger than image size, because could read behind image here. */
+          if (offset1 + j + 1 >= check_buffsize)
+            {
+            printf("Bad input. Preventing reading outside of input buffer.\n");
+            return(-1);
+            }
           bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);
           bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (8 - shift1));
           sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));
